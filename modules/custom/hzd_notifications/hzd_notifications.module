<?php

use Drupal\cust_group\Controller\CustNodeController;
use Drupal\cust_group\CustGroupHelper;
use Drupal\hzd_notifications\Controller\HzdNotifications;
use Drupal\hzd_notifications\HzdNotificationsHelper;

/**
 * Implements callback_batch_operation().
 */
function migrate_each_user($uid, $rel_type, &$context) {
  $default_interval = hzd_get_default_interval($uid, $rel_type);
  // get all services
  $services = hzd_get_all_services($rel_type);
  // user all services interval
  foreach ($services as $services_info) {
    if ($services_info->field_enable_downtime_value && $services_info->release_type_target_id == KONSONS) {
      if (isset($default_interval['downtimes'])) {
        $user_notifications[$services_info->nid]['downtimes'] = $default_interval['downtimes'];
      }
    }
    if ($services_info->field_problem_name_value && $services_info->release_type_target_id == KONSONS) {
      if (isset($default_interval['problem'])) {
        $user_notifications[$services_info->nid]['problem'] = $default_interval['problem'];
      }
    }
    if ($services_info->field_release_name_value) {
      if (isset($default_interval['release'])) {
        $user_notifications[$services_info->nid]['release'] = $default_interval['release'];
      }
    }
    if (isset($default_interval['early_warnings'])) {
      $user_notifications[$services_info->nid]['early_warnings'] = $default_interval['early_warnings'];
    }
  }
  
  // get priority of user services.
  $get_override_services = db_query("SELECT service_id, send_interval, type FROM {service_notifications_override} 
                           WHERE uid = :uid and rel_type = :rel_type", array(":uid" => $uid, ":rel_type" => $rel_type))->fetchAll();
  if (count($get_override_services) > 0) {
    foreach ($get_override_services as $get_override_services_vals) {
      $user_notifications[$get_override_services_vals->service_id][$get_override_services_vals->type] = $get_override_services_vals->send_interval;
    }
  }
  
  foreach ($services as $service_vals) {
    if ($service_vals->field_enable_downtime_value && $service_vals->release_type_target_id == KONSONS) {
      insert_user_service_notifications('downtimes', $service_vals->nid, $uid, $user_notifications);
    }
    if ($service_vals->field_problem_name_value && $service_vals->release_type_target_id == KONSONS) {
      insert_user_service_notifications('problem', $service_vals->nid, $uid, $user_notifications);
    }
    if ($service_vals->field_release_name_value) {
      insert_user_service_notifications('release', $service_vals->nid, $uid, $user_notifications);
    }
    insert_user_service_notifications('early_warnings', $service_vals->nid, $uid, $user_notifications);
  }
}

/**
 * get default intervals of user
 */
function hzd_get_default_interval($uid, $rel_type) {
  $default_intval_per_user = db_query("SELECT service_type, default_send_interval FROM {service_notifications_user_default_interval} 
                               WHERE uid = :uid and rel_type = :type", array(":uid" => $uid, ":type" => $rel_type))->fetchAll();
  $default_interval = array();
  foreach ($default_intval_per_user as $val) {
    $default_interval[$val->service_type] = $val->default_send_interval;
  }
  return $default_interval;
}

/**
 * get all services of a release type
 */
function hzd_get_all_services($rel_type = null) {
  $query = db_select('node_field_data', 'n');
  $query->leftJoin('node__field_release_name', 'nfrn', 'n.nid = nfrn.entity_id');
  $query->leftJoin('node__field_problem_name', 'nfpn', 'n.nid = nfpn.entity_id');
  $query->leftJoin('node__field_enable_downtime', 'nfed', 'n.nid = nfed.entity_id');
  $query->leftJoin('node__release_type', 'nrt', 'n.nid = nrt.entity_id');
  $query->condition('n.type', 'services', '=');
  if ($rel_type) {
    $query->condition('nrt.release_type_target_id', $rel_type, '=');
  }
  $query->fields('n', array('nid'))
    ->fields('nfrn', array('field_release_name_value'))
    ->fields('nfpn', array('field_problem_name_value'))
    ->fields('nrt', array('release_type_target_id'))
    ->fields('nfed', array('field_enable_downtime_value'));
  $result = $query->execute()->fetchAll();
  return $result;
}

/**
 * insert user notifications in service notifications table
 */
function insert_user_service_notifications($type, $nid, $uid, $user_notifications) {
  $interval = HzdNotificationsHelper::hzd_notification_send_interval();
  foreach ($interval as $vals) {
    $uids_list = array();
    $uids_query = db_query("SELECT uids FROM {service_notifications} WHERE service_id = :sid AND type = :type AND send_interval = :intval",
      array(":sid" => $nid, ":type" => $type, ":intval" => $vals))->fetchField();
    $uids_list = unserialize($uids_query);
    if (($key = array_search($uid, $uids_list)) !== false) {
      unset($uids_list[$key]);
    }
    if (isset($user_notifications[$nid][$type]) && ($user_notifications[$nid][$type] == $vals)) {
      $uids_list[] = $uid;
    }
    $serialized_uid = serialize($uids_list);
    db_update('service_notifications')->fields(array('uids' => $serialized_uid))
      ->condition('service_id', $nid)
      ->condition('type', $type)
      ->condition('send_interval', $vals)
      ->execute();
    
  }
}

/**
 * Implements callback_batch_operation().
 */
function migrate_group_each_user($uid, &$context) {
  $default_groups_send_interval = array();
  $default_groups_query = db_query("SELECT DISTINCT value , send_interval FROM {notifications} s, {notifications_fields} nf 
                             WHERE s.sid = nf.sid and  field = :field and uid = :uid", array(":field" => 'group', ":uid" => $uid))->fetchAll();
  foreach ($default_groups_query as $default_groups_info) {
    $default_groups_send_interval[$default_groups_info->value] = $default_groups_info->send_interval;
  }
  
  $user_groups_query = db_query("SELECT gfd.id, gfd.label FROM {groups_field_data} gfd, {group_content_field_data} gcfd 
                       WHERE gfd.id = gcfd.gid AND gcfd.entity_id = :eid", array(":eid" => $uid))->fetchAll();
  $user_groups = array();
  foreach ($user_groups_query as $groups_list) {
    $user_groups[$groups_list->id] = $groups_list->label;
  }
  
  if (count($user_groups) > 0) {
    foreach ($user_groups as $gid => $label) {
      // old ref
      $old_ref = db_query("SELECT field_old_reference_value FROM {group__field_old_reference} 
                 WHERE entity_id = :eid", array(":eid" => $gid))->fetchField();
      if ($old_ref && $default_groups_send_interval[$old_ref]) {
        $int_val = $default_groups_send_interval[$old_ref] ? $default_groups_send_interval[$old_ref] : 0;
        $record = array('uid' => $uid, 'group_id' => $gid, 'group_name' => $label, 'default_send_interval' => $int_val);
        db_insert('group_notifications_user_default_interval')->fields($record)->execute();
      }
    }
  }
}

function migrate_date_field($nid, $date, &$context) {
  $node = \Drupal\node\Entity\Node::load($nid);
  $node->set('field_date_deployed', date('Y-m-d', $date));
  $node->save();
}

function custom_date_deployed_batch_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t("Date field in Deployed releases content type was migrated"));
  } else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    drupal_set_message(
      t('An error occurred while processing @operation with arguments : @args', array(
          '@operation' => $error_operation[0],
          '@args' => print_r($error_operation[0], TRUE),
        )
      )
    );
  }
}

/**
 * implements hook_form_alter
 */
function hzd_notifications_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  if ($form_id == 'node_type_add_form' || $form_id == 'node_type_edit_form') {
    $form['notification'] = array(
      '#type' => 'details',
      '#title' => t('Notifications settings'),
      '#open' => FALSE, // Controls the HTML5 'open' attribute. Defaults to FALSE.
      '#group' => 'additional_settings',
    );
    $form['notification']['notification_checkbox'] = array(
      '#type' => 'checkbox',
      '#title' => t('Notifications'),
      '#default_value' => \Drupal::config('node.settings')->get('notification_checkbox_' . $form['type']['#default_value']) ?: 0,
    );
    $form['actions']['submit']['#submit'][] = 'hzd_notifications_form_submit';
    $form['actions']['save_continue']['#submit'][] = 'hzd_notifications_form_submit';
  }


//   if (isset($group_id))  {
//       $allowed_formids = array(
//      'resolve_form',
//      'cancel_form'
//    );
//    $current_user = \Drupal::service('current_user');
//    $current_user_roles = $current_user->getRoles();
//
//    if (!in_array('site_administrator', $current_user_roles) && (CustNodeController::isGroupAdmin($group_id) == TRUE) && in_array($form_id, $allowed_formids)) {
//      $form['notification'] = array(
//        '#type' => 'details',
//        '#title' => t('Notifications settings'),
//        '#open' => FALSE, // Controls the HTML5 'open' attribute. Defaults to FALSE.
//        '#group' => 'advanced',
//      );
//      $form['notification']['node_notification_checkbox'] = array(
//        '#type' => 'checkbox',
//        '#title' => t('Do not send notifications for this update.'),
//      );
//    }
//    else if ( !in_array('site_administrator', $current_user_roles) && $group->getMember($current_user) && in_array($form_id, $allowed_formids)) {
//      $form['notification'] = array(
//        '#type' => 'details',
//        '#title' => t('Notifications settings'),
//        '#open' => FALSE, // Controls the HTML5 'open' attribute. Defaults to FALSE.
//        '#group' => 'advanced',
//      );
//      $form['notification']['node_notification_checkbox'] = array(
//        '#type' => 'checkbox',
//        '#title' => t('Do not send notifications for this update.'),
//      );
//    }
//  }
}

/**
 * implements custom form submit
 */
function hzd_notifications_form_submit(&$form, \Drupal\Core\Form\FormStateInterface $form_state) {
//  dpm($form_state->getValue('type'), $form_state->getValue('notification_checkbox'));
  \Drupal::configFactory()->getEditable('node.settings')
    ->set('notification_checkbox_' . $form_state->getValue('type'), $form_state->getValue('notification_checkbox'))
    ->save();
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function hzd_notifications_form_node_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state) {
  //Validate content type.
  $type = $form_state->getFormObject()->getEntity()->getType();
  $form_id = $form_state->getBuildInfo()['form_id'];
  if (\Drupal::config('node.settings')->get('notification_checkbox_' . $type)) {
    $current_user = \Drupal::service('current_user');
    $current_user_roles = $current_user->getRoles();
    $group = \Drupal::routeMatch()->getParameter('group');
    $node = \Drupal::routeMatch()->getParameter('node');
    if (!isset($group) && isset($node)) {
      if (is_object($node)) {
        $node_id = $node->id();
      } else {
        $node_id = $node;
      }
      $group_content = CustGroupHelper::getGroupNodeFromNodeId($node_id);
      if ($group_content) {
        $group = $group_content->getgroup();
        $group_id = $group->id();
        $group = \Drupal\group\Entity\Group::load($group_id);
      }
    } else {
      if (is_object($group)) {
        $group_id = $group->id();
      } else {
        $group_id = $group;
        $group = \Drupal\group\Entity\Group::load($group_id);
      }
    }
    
    
    if (isset($group_id)) {
      
      $for_admin_formids = array(
        'node_downtimes_form',
        'node_downtimes_edit_form',
        'node_deployed_releases_edit_form',
        'node_type_edit_form',
      );
      $for_groupadmin_formids = array(
        'node_downtimes_edit_form',
        'node_deployed_releases_edit_form',
      );
      $for_groupmemeber_formids = array(
        'node_downtimes_edit_form',
      );
      
      if (in_array('site_administrator', $current_user_roles) && in_array($form_id, $for_admin_formids)) {
        $form['notification'] = array(
          '#type' => 'details',
          '#title' => t('Notifications settings'),
          '#open' => FALSE, // Controls the HTML5 'open' attribute. Defaults to FALSE.
          '#group' => 'advanced',
        );
        $form['notification']['node_notification_checkbox'] = array(
          '#type' => 'checkbox',
          '#title' => t('Do not send notifications for this update.'),
        );
      } else if ((CustNodeController::isGroupAdmin($group_id) == TRUE) && in_array($form_id, $for_groupadmin_formids)) {
        $form['notification'] = array(
          '#type' => 'details',
          '#title' => t('Notifications settings'),
          '#open' => FALSE, // Controls the HTML5 'open' attribute. Defaults to FALSE.
          '#group' => 'advanced',
        );
        $form['notification']['node_notification_checkbox'] = array(
          '#type' => 'checkbox',
          '#title' => t('Do not send notifications for this update.'),
        );
      } else if (($group->getMember($current_user) && $group->getMember($current_user)->getGroupContent()->get('request_status')->value == 1) && in_array($form_id, $for_groupmemeber_formids)) {
        $form['notification'] = array(
          '#type' => 'details',
          '#title' => t('Notifications settings'),
          '#open' => FALSE, // Controls the HTML5 'open' attribute. Defaults to FALSE.
          '#group' => 'advanced',
        );
        $form['notification']['node_notification_checkbox'] = array(
          '#type' => 'checkbox',
          '#title' => t('Do not send notifications for this update.'),
        );
      }
    }
  }
}

//function notifiction_field_render_in_node_form() {
//  $form = array();
//  $form['notification'] = array(
//    '#type' => 'details',
//    '#title' => t('Notifications settings'),
//    '#open' => FALSE, // Controls the HTML5 'open' attribute. Defaults to FALSE.
//    '#group' => 'advanced',
//  );
//  $form['notification']['node_notification_checkbox'] = array(
//    '#type' => 'checkbox',
//    '#title' => t('Do not send notifications for this update.'),
//  );
//  return $form;
////        if (isset($node) && $node->id()) {
////            $form['actions']['publish']['#submit'][]  = 'hzd_notifications_form_update_node_form_submit';
////        }
////        else {
////            $form['actions']['publish']['#submit'][]  = 'hzd_notifications_form_add_node_form_submit';
////        }
//}      
/**
 * implements custom form submit
 */
//function hzd_notifications_form_update_node_form_submit(&$form, \Drupal\Core\Form\FormStateInterface $form_state) {
//    dpm('update');
//}
//
//function hzd_notifications_form_add_node_form_submit(&$form, \Drupal\Core\Form\FormStateInterface $form_state) {
//    dpm('inset');
//}


function hzd_notifications_user_insert($entity) {
  
//  pr(\Drupal::request()->request->get('groups'));exit;
  $user = $entity->id();
  $data = \Drupal::state()->get('NotificationDefaults');
  $notificationController = new HzdNotifications(\Drupal::routeMatch(), \Drupal::database());
  $notificationController->isNewUser = true;
  $notificationController->setDefaultForQuickInfoNotifications($user, $data['quickinfo']);
  $notificationController->setDefaultForGroupNotifications($user, $data['group']);
  foreach (['downtimes', 'problem', 'release', 'early_warnings'] as $type) {
    $notificationController->setDefaultForServiceTypeNotifications($type, $user, $data[$type]);
  }
//echo $entity->id();exit;
}
