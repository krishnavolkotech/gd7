<?php

//define('RELEASE_MANAGEMENT', 339);
define('SITE_ADMIN', 5);
use Drupal\Core\Url;
use Drupal\Component\Utility\SafeMarkup;

//if(!defined('KONSONS'))
//  define('KONSONS', \Drupal::config('hzd_release_management.settings')->get('konsens_service_term_id'));

/**
 * get deployed services list
 */
function hzd_get_deployed_serivces_list() {
  $current_url = Url::fromRoute('<current>');
  $path = $current_url->toString();
  $current_path = explode("/", $path);

  if(is_numeric($current_path[2])) {
    $type = db_query("SELECT type FROM {node_field_data} WHERE nid = :nid", array(":nid" => $current_path[2]))->fetchField();
  }
  if ($type == 'deployed_releases') {
    $services_releases = released_deployed_releases();
    return $services_data = $services_releases['services'];
  }
  $group_id = ($_SESSION['Group_id'] ? $_SESSION['Group_id'] : RELEASE_MANAGEMENT);
  $services_obj = db_query("SELECT n.title , n.nid FROM {node_field_data} n, {group_releases_view} grv  WHERE n.nid = grv.service_id and grv.group_id = :gid ORDER by title", array(":gid" => $group_id))->fetchAll();
  $services['none'] = " < ".t('Service') . ' > ';

  foreach($services_obj as $services_data) {
    $services[$services_data->nid] = $services_data->title;
  }
  return $services;
}

/**
 * returns the released releses for the deployment 
 */
function released_deployed_releases($service = NULL) {

  $select = "SELECT DISTINCT n.nid as release_id, n.title, nfrs.field_relese_services_target_id as service";
  $from = " FROM {node_field_data} n , {node__field_relese_services} nfrs, {group_releases_view} GRV, {node__field_release_type} nfrt ";
  $where = " WHERE n.nid = nfrs.entity_id AND n.nid = nfrt.entity_id AND n.status = 1 AND nfrs.field_relese_services_target_id = GRV.service_id AND GRV.group_id = :gid AND nfrt.field_release_type_value IN (1, 2) ";
  if ($service) {
    $where .= " AND nfrs.field_relese_services_target_id = $service";
  }
  $order = " ORDER BY n.title ";
  $sql = $select . $from . $where . $order;
  $services = array();
  $query = db_query($sql, array(":gid" => RELEASE_MANAGEMENT))->fetchAll();
  foreach($query as $releases_info) {
    if (!in_array($releases_info->service, $services)) {
      $services[] = $releases_info->service;
    }
    $releases[$releases_info->release_id] = $releases_info->title;
  }

  $deployed_services[] = t('Service');
  if (!empty($services)) {
    $list = implode(", ", $services);
    $sql = db_query("SELECT nid, title FROM {node_field_data} WHERE nid in ($list) ORDER BY title")->fetchAll();
    foreach($sql as $services_info) {
      $deployed_services[$services_info->nid] = $services_info->title;
    }
  }
  return $service_releases = array('services' => $deployed_services, 'releases' => $releases);
}

/**
 * get all non production environment lists
 */
function non_productions_list() {
  $account = \Drupal::currentUser();
  $roles = $account->getRoles();
  if(in_array('site_administrator', $roles)) {
    $non_productions_lists = db_query("SELECT nid, title FROM {node_field_data} WHERE type = :type", array(":type" => 'non_production_environment'))->fetchAll();
  }
  else {
    $state = hzd_user_state();
    $non_productions_lists = db_query("SELECT n.nid, n.title FROM {node_field_data} n, {node__field_non_production_state} nfnps WHERE n.nid = nfnps.entity_id and nfnps.field_non_production_state_value = :state and n.type = :type", array(":state" => $state, ":type" => 'non_production_environment'))->fetchAll();
  }
  $environment_lists[0] = t("Bitte Umgebung auswÃ¤hlen");
  $environment_lists[1] = t('Produktion');
  foreach($non_productions_lists as $vals) {
    $environment_lists[$vals->nid] = $vals->title;
  }
  return $environment_lists;
}

/**
 * get user state id
 */
function hzd_user_state($uid = NULL) {
  if(!$uid) {
    $account = \Drupal::currentUser();
    $uid = $account->id();
  }
  $state = db_query("SELECT state_id FROM {cust_profile} WHERE uid = :uid", array(":uid" => $uid))->fetchField();
  return $state;
}

/**
 * get early warning releases
 */
function hzd_earlywarning_release() {
  $current_url = Url::fromRoute('<current>');
  $path = $current_url->toString();
  $current_path = explode("/", $path);

  if(isset($current_path[2]) && is_numeric($current_path[2])) {
    $type = db_query("SELECT type FROM {node_field_data} WHERE nid = :nid", array(":nid" => $current_path[2]))->fetchField();
  }
  if (isset($type) && $type == 'deployed_releases') {
    $service = Drupal::request()->get('ser');
    $env = Drupal::request()->get('env');
    $release = Drupal::request()->get('rel');
    return get_undeployed_dependent_release($service, $env, $release);
  }
  $options = get_earlywarning_release();
  return $options['releases'];
}

/**
 *Returns the releases associated with the provided sevices
 *@service is service id for which releses has to be returned
 *
 */
function get_earlywarning_release($service = NULL) {
  $group = ($_SESSION['Group_id'] ? $_SESSION['Group_id']: RELEASE_MANAGEMENT);
  $query = db_select('node_field_data', 'nfd');
  $query->join('node__field_relese_services', 'nfrs', 'nfd.nid = nfrs.entity_id');
  $query->join('group_releases_view', 'grv', 'nfrs.field_relese_services_target_id = grv.service_id');
  $query->fields('nfd', array('nid', 'title'))
     ->condition('grv.group_id', $group);
  if($service) {
    $query->condition('nfrs.field_relese_services_target_id', $service);
  }
  $query->orderBy('nfd.title', 'ASC');
  $result = $query->execute()->fetchAll();

  $default_release[] =  t("Release");
  foreach($result as $vals) {
    $default_release[$vals->nid] = $vals->title;
  }
  return array('releases' => $default_release);
}

/*
 *@returns: the releases which are not deployed
 */
function get_undeployed_dependent_release($service = NULL, $environment = NULL, $release = NULL) {
  $releases = released_deployed_releases($service);
  $state_id = hzd_user_state();
  $query = db_select('node_field_data', 'n');
  $query->join('node__field_earlywarning_release', 'nfer', 'n.nid = nfer.entity_id');
  $query->join('node__field_user_state', 'nfus', 'nfus.entity_id = n.nid');
  $query->join('node__field_environment', 'nfe', 'nfe.entity_id = n.nid');
  $query->isNotNull('nfer.field_earlywarning_release_value');
  $query->AddExpression('distinct nfer.field_earlywarning_release_value', 'dep_release');
  $query->condition('nfus.field_user_state_value', $state_id)
        ->condition('n.status', 1);
  if($environment) {
    $query->condition('nfe.field_environment_value', $environment);
  }
  $result = $query->execute()->fetchAll();

  $deployed_releases = array();
  foreach($result as $vals) {
    $deployed_releases[$vals->dep_release] =  $vals->dep_release;
  }

  $undeployed_releases[] = t("Release");
  foreach ($releases['releases'] as $key => $value) {
    if (!in_array($key, $deployed_releases)) {
      $undeployed_releases[$key] = $value; 
    }
  }
  if($release) {
    $deployed_nid = db_query("SELECT field_earlywarning_release_value FROM {node__field_earlywarning_release} nfer, {node__field_environment} nfe WHERE nfe.entity_id = nfer.entity_id and nfe.field_environment_value = :env and nfe.entity_id = :eid", array(":env" => $environment, ":eid" => $release))->fetchField();
    if ($deployed_nid) {
      $title = db_query("SELECT title FROM {node_field_data} WHERE nid = :nid", array(":nid" => $deployed_nid))->fetchField();
      $undeployed_releases[$deployed_nid] = $title;
    }
  }
  return $undeployed_releases;
}

function get_release($string = NULL, $service = NULL) {
  $release_type = get_release_type($string);
  $query = db_query("SELECT n.nid, n.title from {node_field_data} n, {node__field_relese_services} nfrs, 
         {group_releases_view} GRV, {node__field_release_type} nfrt 
         WHERE n.nid = nfrs.entity_id and nfrt.entity_id = n.nid 
         and nfrs.field_relese_services_target_id = GRV.service_id 
         and GRV.group_id = :gid
         and nfrt.field_release_type_value = :type
         and nfrs.field_relese_services_target_id = :sid ORDER by title", 
         array(":gid" => RELEASE_MANAGEMENT, ":type" => $release_type, ":sid" => $service))->fetchAll();
  
  $default_release[] = t("Releases");
  foreach($query as $function) {
    $default_release[$function->title] = $function->title;
  }
  return array('releases' => $default_release);
}

/*
 *Returns the type of release
*/
function get_release_type($type) {
  switch ($type) {
  case 'released':
    $release_type = 1;
    break;
  case 'progress':
    $release_type = 2;
    break;
  case 'locked':
    $release_type = 3;
    break;
  case 'rejected':
    $release_type = 4;
    break;
  }
  return  $release_type ;
}


/**
 * Implementation of hook_cron()
 */
function release_management_cron() {
  $set_time = trim(variable_get('import_time_releases','03:00'));
  $time = date("H:i", time());
  if ($set_time == $time) {
    read_release_csv();
  }
}

/*
 * @return:returns abbreviations of states from states table
 */

function get_all_user_state($active = 0) {
  if ($active) {
    $sql_active = "where active = 1";
  }
  else {
    $sql_active = "";
  }
  $user_states = db_query("select id, concat(state,' (',abbr,')') as state from {states} $sql_active ORDER BY weight ASC")->fetchAll();
  foreach($user_states as $states_values) {
    // when we concat, when no abbr value is present, then it returns NULL. As of now it returns NULL for please select. so adding that value back to show in drop down.
    if ($states_values->state == NULL) {
      $states[$states_values->id] = 'Bundesland';
    }
    else {
      $states[$states_values->id] = $states_values->state;
    }
  }
  return $states;
}

/**
 *  get non production environments list when the state was selected.
 */
function get_environment_options($state = 1) {
  $environment_lists[0] = t('All');
  $environment_lists[1] = t('Produktion');
  if ($state != 1) {
    $non_productions_lists = db_query("SELECT n.nid, n.title FROM {node_field_data} n, {node__field_non_production_state} nfns WHERE n.nid = nfns.entity_id and nfns.field_non_production_state_value = :val and n.type = :type", array(":val" => $state, "type" => 'non_production_environment'))->fetchAll();
    foreach($non_productions_lists as $row) {
      $environment_lists[$row->nid] = $row->title;
    }
  }
  return $environment_lists;
}

// send immediate release notifications.
function send_release_notifications($entity) {
  $nid = $entity->id();
  $service_field = $entity->get('field_relese_services')->getValue();
  $service_id = $service_field[0]['target_id'];
  
  // get immediate notifications user mails
  $result = hzd_get_immediate_notification_user_mails($service_id, 'release');
  if(is_array($result) && count($result) > 0) {
    foreach($result as $values) {
      $preference = $values->field_message_preference_value ? $values->field_message_preference_value : 'html';
      $mail = $values->mail;
      // trigger mail functionality to send immediate notifications of quickinfo
      $token_service = \Drupal::token();
      $token_sub = \Drupal::config('hzd_notifications.settings')->get('node_creation_subject');
      $subject = $token_service->replace($token_sub, array('node' => $entity));
      $token_body = \Drupal::config('hzd_notifications.settings')->get('node_creation_body')['value'];
      // Replace the token for subject.
      $message_text = $token_service->replace($token_body, array('node' => $entity));
      send_immediate_notifications($subject, $message_text, $mail, $preference);
    }
  }
}

// send immediate release notifications.
function send_problem_notifications($entity) {
  $service_field = $entity->get('field_services')->getValue();
  $service_id = $service_field[0]['target_id'];
  
  // get immediate notifications user mails
  $result = hzd_get_immediate_notification_user_mails($service_id, 'problem');
  if(is_array($result) && count($result) > 0) {
    foreach($result as $values) {
      $preference = $values->field_message_preference_value ? $values->field_message_preference_value : 'html';
      $mail = $values->mail;
      // trigger mail functionality to send immediate notifications of quickinfo
      $token_service = \Drupal::token();
      $token_sub = \Drupal::config('hzd_notifications.settings')->get('node_creation_subject');
      $subject = $token_service->replace($token_sub, array('node' => $entity));
      $token_body = \Drupal::config('hzd_notifications.settings')->get('node_creation_body')['value'];
      // Replace the token for subject.
      $message_text = $token_service->replace($token_body, array('node' => $entity));
      send_immediate_notifications($subject, $message_text, $mail, $preference);
    }
  }
}

// send immediate planning files notifications.
function send_pf_notifications($entity) {
  $result = hzd_get_immediate_pf_notification_user_mails();
  if(is_array($result) && count($result) > 0) {
    foreach($result as $values) {
      $preference = $values->field_message_preference_value ? $values->field_message_preference_value : 'html';
      $mail = $values->mail;
      // trigger mail functionality to send immediate notifications of quickinfo
      $token_service = \Drupal::token();
      $token_sub = \Drupal::config('hzd_notifications.settings')->get('node_creation_subject');
      $subject = $token_service->replace($token_sub, array('node' => $entity));
      $token_body = \Drupal::config('hzd_notifications.settings')->get('node_creation_body')['value'];
      // Replace the token for subject.
      $message_text = $token_service->replace($token_body, array('node' => $entity));
      send_immediate_notifications($subject, $message_text, $mail, $preference);
    }
  }
}

// send immediate Quickinfo Notifications
// TODONOTIFICATIONS
function send_qi_notifications($entity) {
    return;
  $services = $entity->get('field_other_services')->getValue();
  $result = hzd_get_immediate_qi_notification_user_mails($services);
  if(is_array($result) && count($result) > 0) {
    foreach($result as $values) {
      $preference = $values->field_message_preference_value ? $values->field_message_preference_value : 'html';
      $mail = $values->mail;
      // trigger mail functionality to send immediate notifications of quickinfo
      $token_service = \Drupal::token();
      $q_sub = \Drupal::config('hzd_notifications.settings')->get('quickinfo_subject');
      $subject = $token_service->replace($q_sub, array('node' => $entity));
      $q_body = \Drupal::config('hzd_notifications.settings')->get('quickinfo_body')['value'];
      // Replace the token for subject.
      $message_text = $token_service->replace($q_body, array('node' => $entity));
      send_immediate_notifications($subject, $message_text, $mail, $preference);
    }
  }
}

/**
 * implements hook_ENTITY_TYPE_insert()
 */
function hzd_release_management_node_insert($entity) {
  if($entity->getType() == 'release') {
    send_release_notifications($entity);
  }
  if($entity->getType() == 'problem') {
    send_problem_notifications($entity);
  }
  if($entity->getType() == 'downtimes') {
    
  }
  if($entity->getType() == 'planning_files') {
    send_pf_notifications($entity);
  }

  if($entity->getType() == 'quickinfo') {
    send_qi_notifications($entity);
  }

  if($entity->getType() == 'services') {
    $nid = $entity->id();
    $rel_type = $entity->get('release_type')->getValue()[0]['target_id'];
    $downtime = $entity->get('field_enable_downtime')->getValue()[0]['value'];
    $problem = $entity->get('field_problem_name')->getValue()[0]['value'];
    $release = $entity->get('field_release_name')->getValue()[0]['value'];

    if($downtime && $rel_type == KONSONS) {
      insert_new_service_notifications('downtimes', $nid);
    }
    if($problem != '' && $rel_type == KONSONS) {
	    insert_new_service_notifications('problem', $nid);
    }
    if($release != '') {
      insert_new_service_notifications('release', $nid);
    }
    insert_new_service_notifications('early_warnings', $nid);
  }
}

// get user mail ids
function hzd_get_immediate_notification_user_mails($service_id, $type) {
  $get_immediate_notifications_users = db_query("SELECT uids FROM {service_notifications} WHERE service_id = :sid AND send_interval = :intval AND type = :type", array(":sid" => $service_id, ":intval" => 0, ":type" => $type))->fetchField();
  $unserialized_user_array = unserialize($get_immediate_notifications_users);
  if(is_array($unserialized_user_array) && count($unserialized_user_array) > 0) {
    return hzd_user_mails($unserialized_user_array);
  }
  return '';
}

function hzd_get_immediate_pf_notification_user_mails() {
  $get_pf_immediate_notifications_users = db_query("SELECT uids FROM {planning_files_notifications} WHERE send_interval = :intval", array(":intval" => 0))->fetchField();
  $unserialized_user_array = unserialize($get_pf_immediate_notifications_users);
  if(is_array($unserialized_user_array) && (count($unserialized_user_array) > 0)) {
    return hzd_user_mails($unserialized_user_array);
  }
  return '';
}

function hzd_get_immediate_qi_notification_user_mails($services) {
  $options = \Drupal\field\Entity\FieldStorageConfig::loadByName('node','field_other_services')->getSetting('allowed_values');
  $affetced_services = array();
  foreach($services as $val) {
    $affetced_services[] = $options[$val['value']];
  }

  $query = db_select('quickinfo_notifications','q')
         ->fields('q', array('uids'))
         ->condition('q.cck', $affetced_services,'IN')
         ->condition('q.send_interval', 0, '=');
   
  $results = $query->execute()->fetchCol();
  $uids_list = array();
  foreach($results as $serialized_uids) {
    $uids = unserialize($serialized_uids);
    $uids_list = array_unique(array_merge($uids_list, $uids));
  }
  
  if(is_array($uids_list) && (count($uids_list) > 0)) {
    return hzd_user_mails(array_values($uids_list));
  }
  return '';
}

// get user mail ids
function hzd_user_mails($uids) {
  $query = db_select('users_field_data', 'u');
  $query->leftjoin('user__field_message_preference', 'ufmp', 'u.uid = ufmp.entity_id');
  $query->condition('u.status', 1, '=')
         ->fields('ufmp', array('field_message_preference_value'))
         ->condition('u.uid', $uids, 'IN')
         ->groupBy('ufmp.field_message_preference_value');
  $query->addExpression("GROUP_CONCAT(u.mail separator ', ')", "mail");
  $result = $query->execute()->fetchAll();
  return $result;
}

// send immediate notifications
function send_immediate_notifications($subject, $message_text, $to, $preference) {
  $mailManager = \Drupal::service('plugin.manager.mail');
  $module = 'hzd_release_management';
  $key = 'immediate_notifications';
  $params['message'] = $message_text;
  $params['subject'] = $subject;
  $params['preference'] = $preference ? $preference : 'html';
  $langcode = \Drupal::currentUser()->getPreferredLangcode();
  $send = true;
  $result = $mailManager->mail($module, $key, $to, $langcode, $params, NULL, $send);
  if($result['result'] !== true) {
    drupal_set_message(t('There was a problem sending your message and it was not sent.'), 'error');
  }
}

/**
 * implements hook_mail
 */
function hzd_release_management_mail($key, &$message, $params) {
  $options = array(
    'langcode' => $message['langcode'],
  );
  switch ($key) {
    case 'immediate_notifications':
      $message['from'] = \Drupal::config('system.site')->get('mail');
      $message['subject'] = $params['subject'];
      $message['body'][] = SafeMarkup::checkPlain($params['message']);
      $message['headers']['Content-Type'] = ($params['preference'] == 'html') ? 'text/html; charset=UTF-8; format=flowed; delsp=yes' : 'text/plain; charset=UTF-8; format=flowed; delsp=yes';
      $message['headers']['Bcc'] = 'shiva.chevva@gmail.com';
      break;
  }
}

/**
 * implements hook_ENTITY_TYPE_delete()
 */
function hzd_release_management_node_delete($entity) {
  if($entity->getType() == 'services') {
    $nid = $entity->id();
    db_delete('service_notifications')->condition('service_id', $nid)->execute();
  }
}

/**
 * implements hook_ENTITY_TYPE_update()
 */
function hzd_release_management_node_update($entity) {
  if($entity->getType() == 'services') {
    $nid = $entity->id();
    $diff = $entity->get('field_diff')->getValue()[0]['value'];
    if($nid) {
      update_service_notifications($entity);
      //update_service_notifications('downtimes', $nid);
    }
  }
  if($entity->getType() == 'release') {
    send_release_notifications($entity);
  }
  if($entity->getType() == 'problem') {
    send_problem_notifications($entity);
  }
  if($entity->getType() == 'planning_files') {
    send_pf_notifications($entity);
  }
  if($entity->getType() == 'quickinfo') {
    send_qi_notifications($entity);
  }
}

function update_service_notifications($entity) {
  $rel_type = $entity->get('release_type')->getValue()[0]['target_id'];
  $downtime = $entity->get('field_enable_downtime')->getValue()[0]['value'];
  $problem = $entity->get('field_problem_name')->getValue()[0]['value'];
  $release = $entity->get('field_release_name')->getValue()[0]['value'];
  if($downtime) {
    hzd_notifications_delete_subscriptions('downtime', $entity->id());
    if ($rel_type == KONSONS) {
      hzd_service_update_notifications('downtimes', $entity->id());
    }
  }
  else {
    hzd_notifications_delete_subscriptions('downtime', $entity->id());
  }

  // Problems insert or delete
  if($problem != '') {
    hzd_notifications_delete_subscriptions('problem', $entity->id());
    if ($rel_type == KONSONS) {
      hzd_service_update_notifications('problem', $entity->id());
    }
  }
  else {
    hzd_notifications_delete_subscriptions('problem', $entity->id());
  }

  // Release insert or delete
  if ($release != "") {
    hzd_notifications_delete_subscriptions('release', $entity->id());
    hzd_service_update_notifications('release', $entity->id());
  }
  else {
    hzd_notifications_delete_subscriptions('release', $entity->id());
  }
}

function hzd_service_update_notifications($type, $nid) {
  $default_interval = array('-1', 0, 86400, 604800);
  $service_notifications = db_query("SELECT uid, default_send_interval FROM {service_notifications_user_default_interval} WHERE service_type = :type AND uid <> 0 ORDER BY uid ASC", array(":type" => $type))->fetchAll();
  $result = array();
  foreach($service_notifications as $vals) {
    $result[$vals->uid] = $vals->default_send_interval;
  }
  $override = db_query("SELECT uid, send_interval FROM {service_notifications_override} WHERE service_id = :sid AND type = :type", array(":sid" => $nid, ":type" => $type))->fetchAll();
  foreach($override as $overrides_services) {
    $result[$overrides_services->uid] = $overrides_services->send_interval;
  }
  
  //group by interval
  $updated_result = array();
  foreach($result as $key => $interval) {
    $updated_result[$interval][] = $key;
  }

  foreach($default_interval as $send_interval) {
    $serialized_uids = serialize($updated_result[$send_interval]);
    $record = array('service_id' => $nid, 'type' => $type, 'send_interval' => $send_interval, 'uids' => $serialized_uids);
	  db_insert('service_notifications')->fields($record)->execute();
  }
}

function hzd_notifications_delete_subscriptions($type, $nid) {
  db_delete('service_notifications')->condition('service_id', $nid, '=')->condition('type', $type, '=')->execute();
}

function insert_new_service_notifications($type, $nid) {
  $interval = array('-1', 0, 86400, 604800);
  $service_notifications = db_query("SELECT uid, default_send_interval FROM {service_notifications_user_default_interval} WHERE service_type = :type AND uid <> 0 ORDER BY uid ASC", array(":type" => $type))->fetchAll();
  $result = array();
  foreach($service_notifications as $vals) {
    $result[$vals->default_send_interval][$vals->uid] = $vals->uid;
  }

  foreach($interval as $each_interval) {
    foreach($result as $service_vals) {
      $serialized_uids = serialize($service_vals);
      $record = array('service_id' => $nid, 'type' => $type, 'send_interval' => $each_interval, 'uids' => $serialized_uids);
	    db_insert('service_notifications')->fields($record)->execute();
    }
  }
}
/*
use Drupal\Core\Access\AccessResult;
function hzd_release_management_group_access(\Drupal\Core\Entity\EntityInterface $entity, $operation, \Drupal\Core\Session\AccountInterface $account){
  if(in_array('site_administrator',$account->getRoles())){
    //    return AccessResult::allowed();
  }else{
    
  }
  //  return true;
  //  pr($entity->toArray());
  //exit;
  }*/